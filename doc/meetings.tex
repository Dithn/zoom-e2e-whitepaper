This section describes the cryptographic design that powers Zoom Meetings. We offer two types of
encryption for Meetings: enhanced encryption encrypts the meeting stream with a key which is
available to the Zoom server infrastructure, allowing for features such as cloud recording and live
captioning, as well as the opportunity to dial into a meeting from a mobile or landline phone.
End-to-end encryption, on the other hand, ensures that only the clients of the participants who are
in the meeting have access to the meeting key. This offers stronger security and privacy, but lacks
all the features that require the server to be able to decrypt meeting contents.

\subsection{Zoom Meetings}
\label{subsec:general-meetings}
A Zoom meeting is initiated by a designated individual, who we will refer to as the host. The host
has the ability to configure meetings, notify participants, select meeting passwords, and control
meeting functions while a meeting is in progress. The host's configured policies (e.g., whether
meeting participants may share their screens by default) are applied to the meeting. The host need
not be present for the entire duration of a meeting: if ``Join Before Host'' is enabled, individuals
can begin a meeting before the host joins. Similarly, a host can appoint one or more additional
individuals as co-hosts and can leave the meeting under the control of a replacement host.

Each Zoom meeting involves up to 1,000 participants. Meetings are identified externally by a short
meeting identifier (the meeting ID), known to the Zoom infrastructure, which each participant must
possess as a precondition for joining a meeting. 

During meeting setup/scheduling, users can select enhanced or end-to-end encryption. This option
cannot be changed once the meeting starts, and all participants receive a clear indication of the
type of encryption during the meeting. 

Zoom meetings also feature several access control mechanisms, among which are:

\begin{itemize*}
\item A shared meeting password, which can be selected by the host at the time the meeting is
configured.
\item A ``Waiting Room'' feature, in which the host (and replacement host) has the ability to
manually approve entry of participants throughout the course of a live meeting. Participants are
identified by a name of their choosing.
\item A mechanism by which meeting participants must register prior to the meeting.
\item A setting to limit attendees of a meeting to those who are signed-in and authenticated members
of certain domains.
\end{itemize*}

We stress that these mechanisms are powered by the server, and might be circumvented by insiders.

\subsection{Enhanced Encryption}
When a Zoom client enters a Zoom meeting with enhanced encryption, it gets a 256-bit per-meeting key
(\MK) generated by the Zoom server, which retains the key to distribute it to participants as they
join\footnote{While in the waiting room, participants do not have access to the meeting key, and
therefore their chat messages are sent and received using TLS.}. During meetings, each participant
might produce different data streams such as audio, video and screen sharing. Since Zoom client
version 5.0, each stream consists of UDP packets that are encrypted (in both enhanced and end-to-end
encrypted meetings) using AES256-GCM with a unique per-stream key, derived from the meeting key and
a (non-secret) stream identifier using an HMAC.

Those packets are relayed and multiplexed via one or more Multimedia Routers (MMR) in Zoom's
infrastructure. The MMR servers do not decrypt these packets to route them, and use the per-meeting
key only to provide the special features (such as PSTN dial-in and Cloud Recording) as detailed
below. There is also no mechanism to re-key a meeting.

If a PSTN or SIP client is authorized to join, the MMR provides the per-meeting encryption key to
specialized connector servers in Zoom's infrastructure. These servers act as a proxy: they decrypt
and composite the meeting content streams in the same manner as a Zoom client and then re-encode the
content in a manner appropriate for the connecting client. Zoom's optional Cloud Recording feature
works similarly, recording the decrypted streams and hosting the resulting file in Zoom's cloud for
the user to access. In the current design, Zoom's infrastructure brokers access to the meeting key.

This design provides confidentiality and authenticity for all Zoom data streams by providing
encryption between Zoom client endpoints and the servers. However, it does not provide end-to-end
key management. In meetings using enhanced encryption, a passive adversary who has access to the
memory of the relevant Zoom servers may be able to breach confidentiality, by observing the shared
meeting key, deriving session keys, and decrypting all meeting data. Zoom meetings with enhanced
encryption, as well as virtually every other cloud product, rely on securing the server
infrastructure in order to achieve overall security; end-to-end encryption, using keys at the
endpoints only, allows us to reduce reliance on the security of the Zoom infrastructure.

\subsection{End-to-End Encryption}
Our end-to-end encryption design eliminates Zoom servers' role in generating (and controlling access
to) the meeting key, shifting this responsibility to the participants' Zoom clients. No secret key
material or unencrypted meeting contents will be provided to Zoom infrastructure servers, except in
specific cases where this sharing is explicitly authorized by meeting participants (e.g., to support
abuse reporting).

In end-to-end encrypted meetings:
\begin{itemize*}
   \item ``Join Before Host'' and Cloud Recording cannot be enabled.
   \item All participating clients must run the official Zoom client software; it is not possible to
   join using dial-ins, web browsers, or legacy Zoom-enabled devices.
   \item Participants can see a ``meeting leader security code'' that they can use to verify that no
   one's connection to the meeting is being tampered with. The host can read this code out loud, and
   all participants can check that their clients display the same code.   
\end{itemize*}

\subsubsection{Security Goals}

Zoom Meetings shares the goals, threat model, and limitations of
Section~\ref{sec:background_and_goals} with the other products outlined in this document. Specific
to Zoom Meetings, we additionally deem {\bf in-meeting impersonation attacks} to be out of scope: a
malicious but otherwise authorized meeting participant colluding with a malicious server can
masquerade as another authorized meeting participant.

There are also several legacy standards and platforms that E2E encryption for Zoom Meetings is not
compatible with. For example, dial-in phones or SIP/H.323 devices can be used to join Zoom Meetings,
but these devices cannot be modified to support end-to-end encryption and require meeting content to
be decrypted and re-encoded in an ``end'' in Zoom's data center. The E2E security guarantees
described in this section do not apply to meetings that support such features.

In addition, we also provide post-quantum security for meeting encryption (but not authentication),
in an effort to guard against a future quantum adversary possessing previously recorded meeting
data.

\subsection{System Components}
\label{subsec:comp}

Our end-to-end encryption protocol assumes the following components:
\begin{description}
\item {\bf Identity management system.} The system depends on the existence of a Zoom ID management
system that will be responsible for distributing cryptographic public keys generated by individual
clients. This server will bind keys to Zoom user accounts where possible, and will also support
clients who do not have explicit Zoom identities.

\item {\bf Signaling channel.} The system will make use of a signaling channel to distribute
cryptographic messages between participants in a meeting. Currently, meeting participants route
control messages on TLS-tunnels over TCP, through the MMRs. TLS is terminated at Zoom's servers.
This channel is suitable for our needs.

\item {\bf Bulletin board.} Participants in the channel can post cryptographic messages to a
meeting-specific ``bulletin board,'' where all other participants can see them. This abstraction can
be implemented over the signaling channel. The server controls the bulletin board, as it controls
the signaling channel itself, and therefore can tamper with it.

\item {\bf Meeting leader.} The protocol requires that, at all times, one of the participants plays
the role of the meeting ``leader.'' This client will have the responsibility of generating and
updating the shared meeting key, and to distribute this key and other meeting metadata to the other
participants. Zoom servers will select the leader, and replace them with a new one if the current
one leaves. Note that the meeting leader role is different from the meeting host, who can authorize
and kick out participants and has administrative control over meeting functionality. Before version
5.11.3, clients enforce that the leader is always the host, and this will still be the case in most
meetings; however, newer clients allow the server to assign these roles independently to support
functionality like E2EE Breakout Rooms, which do not have a dedicated host.

\end{description}

\subsection{Cryptographic Algorithms}\label{subsec:cryptoalgs}

All meeting data sent over UDP gets encrypted with AES in GCM mode~\cite{sp80038d}.
%
Key derivation uses the HKDF algorithm~\cite{rfc5869}.
%
For key agreement and signing, we rely on Diffie-Hellman over
Curve25519~\cite{bernstein2006curve25519} and EdDSA over Ed25519~\cite{eddsa}.
%
For encryption, we use an interface of the NaCl~\cite{nacl}-inspired \sodium{}
library~\cite{libsodium} (though implemented using OpenSSL~\cite{openssl} and strengthened to achieve post-quantum security), as detailed below.
%
We leverage Kyber768~\cite{kyber} as a post-quantum key encapsulation mechanism. Kyber is based on the module-learning-with-errors problem and has won the first NIST post-quantum cryptography competition~\cite{nistpqc}. We use the official reference implementation codebase~\cite{kybercode}.

\subsubsection{Signing}

For signing, we use \sodium 's EdDSA interface (implemented in OpenSSL):
%
\begin{itemize*}
   \item $\zoomsignkeygen$ generates a key pair $(\vkzoomsign, \skzoomsign)$ (via
   \texttt{crypto\_sign\_keypair}).
   \item $\zoomsignsign$ takes as input a context string $\context$ and a message $M$ and outputs a
   ``detached'' signature $\signaturezoomsign$ over $\SHATWO(\context) || \SHATWO(M)$ (via
   \texttt{crypto\_sign\_detached}).
   \item $\zoomsignverify$ takes as input a detached signature $\signaturezoomsign$, a context
   string $\context$, and a message $M$; it outputs $\true$ on verification success and $\false$ on
   failure (via \texttt{crypto\_\-sign\_\-verify\_\-detached}).
\end{itemize*}

\subsubsection{Authenticated Public-Key Encryption}\label{subsubsec:meetingcrypto}

Authenticated public-key encryption uses \sodium{} interfaces (implemented in OpenSSL) and Kyber for post-quantum security%
%
\footnote{Post-quantum algorithm support for Zoom Meetings was added in client version 6.0.10, and the post-quantum properties are achieved only as long as all meeting participants use a supported client version. Otherwise, the leader will send the meeting key to the out-of-date participants using the standard protocol (described in previous versions of this whitepaper). Once enough time has been allowed for clients to upgrade and we enforce a sufficiently high minimum client version, we will stop supporting standard E2EE entirely.}.
%
Note that in encryption and decryption, we first
derive pairwise shared keys by combining the output of a Curve25519 Diffie-Hellman key exchange and a Kyber768 key encapsulation, and then use this shared key to encrypt/decrypt messages as a separate step. This allows caching, enables us to support associated data (which the \sodium{} interface does not directly expose for asymmetric encryption), and also allows us to rely on Kyber for post-quantum security. The two outputs are combined using the more modern $\SHATHREE$ cryptographic hash function; the hash inputs also include a context string and the parties' public keys (as inspired by the XWing construction~\cite{xwing}).

%%%%%%%%%%%%%%%%%%%%%
% CRYPTO_BOX KEYGEN
%%%%%%%%%%%%%%%%%%%%%

{\underline {\bf \cboxkeygen}}\\
{\bf Input:} None \\
{\bf Output:} an encryption keypair $(\pk,\sk)$ \\

To generate a key pair:

\vspace{-1.5em}
\begingroup
\RaggedRight
\begin{enumerate*}
\item Return $((\pkbox, \pkkyber), (\skbox,  \skkyber))$ as generated by \texttt{crypto\_box\_keypair} and \texttt{crypto\_kem\_keypair}.
\end{enumerate*}
\endgroup

%%%%%%%%%%%%%%%%%%%%%
% CRYPTO_BOX ENCRYPT
%%%%%%%%%%%%%%%%%%%%%

{\underline {\bf \cboxencrypt}} \\
{\bf Input:} Sender's secret key $\skboxS$, sender's public keys $(\pkboxS, \pkkyberS)$ and receiver's public keys $(\pkboxR, \pkkyberR)$, sender's long-term signing public key $vk^\textsf{S}$, receiver's long-term signing public key $vk^\textsf{R}$, a context string
$\context_\textsf{KDF}$, a second context string $\context_\textsf{cipher}$, metadata $\metadata$,
and a message $M$. \\
{\bf Output:} a ciphertext $\ciphertext$ \\

\vspace{-1.5em}
To encrypt:

\vspace{-1.5em}
\begingroup
\RaggedRight
\begin{enumerate*}
\item Generate a 192-bit random string $\randomNonce$.
\item Compute $K_{\sfbox} \leftarrow \texttt{crypto\_box\_beforenm}(\pkboxR, \skboxS)$, which is the Diffie-Hellman key-exchange of the public key $\pkboxR$ and the private key $\skboxS$.
\item Compute $K_{\kyber}, C_{\kyber} \leftarrow \kyberkemenc(\pkkyberR)$.
\item Compute $\textsf{CombinationAssociatedData}$ as a canonical hash \\ over $vk^\textsf{S}, \pkboxS, \pkkyberS, vk^\textsf{R}, \pkboxR, \pkkyberR$.
\item Compute $S \leftarrow \SHATHREE(\context || K_{\kyber} || K_{\sfbox} || \textsf{CombinationAssociatedData})$
\item Compute $K \leftarrow \HKDF(S, \metadata, \context_{\textsf{KDF}}, 32)$
\item Compute $D \leftarrow \SHATWO(\context_\textsf{cipher}) || \SHATWO(\metadata)$.
\item Compute $C' \leftarrow \texttt{crypto\_aead\_xchacha20poly1305\_ietf\_encrypt}(M, D,
\randomNonce,$ $K)$, which computes XChaCha20-Poly1305 over the plaintext $M$ with the symmetric key
$K$, the associated data $D$, and the nonce $\randomNonce$.
\item Output $C \leftarrow (C', \randomNonce, C_{\kyber})$.
\end{enumerate*}
\endgroup

% CRYPTO_BOX DECRYPT
%%%%%%%%%%%%%%%%%%%%%

{\underline {\bf \cboxdecrypt}} \\
{\bf Input:} Receiver's secret keys $(\skboxR,\skkyberR)$, receivers's public keys $(\pkboxR, \pkkyberR)$ and sender's public keys $(\pkboxS,\pkkyberS)$, sender's long-term signing public key $vk^\textsf{S}$, receiver's long-term signing public key $vk^\textsf{R}$, a context string
$\context_\textsf{KDF}$, a second context string $\context_\textsf{cipher}$, metadata $\metadata$,
and a ciphertext $\ciphertext$. \\
{\bf Output:} a message $M$, or ${\sf error}$

To decrypt:

\vspace{-1em}
\begingroup
\RaggedRight
\begin{enumerate*}
\item Parse $\ciphertext$ as $(C', \randomNonce, C_{\kyber})$.
\item Compute $K_{\sfbox} \leftarrow \texttt{crypto\_box\_beforenm}(\pkboxS, \skboxR)$.
\item Compute $K_{\kyber} \leftarrow \kyberkemdec(\skkyberR,C_{\kyber})$.
\item Compute $\textsf{CombinationAssociatedData}$ as a canonical hash \\ over $vk^\textsf{S}, \pkboxS, \pkkyberS, vk^\textsf{R}, \pkboxR, \pkkyberR$.
\item Compute $S \leftarrow \SHATHREE(\context || K_{\kyber} || K_{\sfbox} || \textsf{CombinationAssociatedData})$
\item Compute $K \leftarrow \HKDF(S, \metadata, \context_{\textsf{KDF}}, 32)$
($K$ may be cached for this key pair and context.)
\item Compute $D \leftarrow \SHATWO(\context_\textsf{cipher}) || \SHATWO(\metadata)$.
\item Compute $M \leftarrow \texttt{crypto\_aead\_xchacha20poly1305\_ietf\_decrypt}(C', D,
\randomNonce,$ $K)$. If decryption fails, output $\errorSym$. Otherwise output $M$.
\end{enumerate*}
\endgroup

\subsection{Join/Leave Protocol flow}\label{subsec:joinleave}

Each client needs a device signing key pair to join E2EE meetings: we denote the public verification
key as $\ivk$, and the secret signing key as $\isk$.

Once sigchain-backed identity for meetings (Section~\ref{subsec:keyagreementidentity}) is available,
devices will directly use their signing key pairs as advertised in the user's sigchain.  Until then,
each device generates a dedicated $\ivk/\isk$ pair using $\zoomsignkeygen$ on their first login. In
all cases, these signing keys are securely stored as described in Section~\ref{subsec:lks}.

If the user is joining a meeting as a guest (without logging in), this key pair
is freshly generated for every meeting and never recorded in the sigchain. This
prevents other participants from tracing them
across meetings by noticing when a long-term key is reused.

We assume each meeting is identified by its unique $\meetingID$, as in the current system. Each
meeting gets its own ``bulletin board'' that's accessible to everyone who has server-gated access to
the meeting. The server clears it when the meeting ends. Note that meetings can be ended then later
restarted, and a meeting ID can refer to a standing or repeating meeting.

From a cryptographic perspective, the server is free to tamper with all values posted on the
bulletin board. In Section~\ref{subsec:secprop}, we describe further that a malicious server that
sends stale messages from a previous meeting incarnation can at best deny service, which it can do
regardless.

Figure~\ref{fig:ladder} describes the basic flow of a leader admitting a participant into the
meeting.

% Agents
\def\Bob{Bob}
\def\MMR{Zoom MMR}
\def\Keyserver{Zoom Keyserver}
\def\Alice{Alice}

% Diagram
\begin{figure}[h]
\begin{tikzpicture}[every node/.style={font=\small,minimum height=1cm,minimum width=0.5cm},]

% Matrix
\node [matrix, very thin,column sep=1.5cm,row sep=.2cm] (matrix) at (0,0) {
  & \node(0,0) (\Bob) {}; && \node(0,0) (\MMR) {}; && \node(0,0) (\Keyserver) {}; && \node (\Alice) {}; \\
  & \node(0,0) (\Bob 1) {}; && \node(0,0) (\MMR 1) {}; && \node(0,0) (\Keyserver 1) {}; && \node (\Alice 1) {}; \\
  & \node(0,0) (\Bob 105) {}; && \node(0,0) (\MMR 105) {}; && \node(0,0) (\Keyserver 105) {}; && \node (\Alice 105) {}; \\
  & \node(0,0) (\Bob 2) {}; && \node(0,0) (\MMR 2) {}; && \node(0,0) (\Keyserver 2) {}; && \node (\Alice 2) {}; \\
  & \node(0,0) (\Bob 3) {}; && \node(0,0) (\MMR 3) {}; && \node(0,0) (\Keyserver 3) {}; && \node (\Alice 3) {}; \\
  & \node(0,0) (\Bob 4) {}; && \node(0,0) (\MMR 4) {}; && \node(0,0) (\Keyserver 4) {}; && \node (\Alice 4) {}; \\
  & \node(0,0) (\Bob 7) {}; && \node(0,0) (\MMR 7) {}; && \node(0,0) (\Keyserver 7) {}; && \node (\Alice 7) {}; \\
  & \node(0,0) (\Bob 8) {}; && \node(0,0) (\MMR 8) {}; && \node(0,0) (\Keyserver 8) {}; && \node (\Alice 8) {}; \\
  & \node(0,0) (\Bob 9) {}; && \node(0,0) (\MMR 9) {}; && \node(0,0) (\Keyserver 9) {}; && \node (\Alice 9) {}; \\
  & \node(0,0) (\Bob 10) {}; && \node(0,0) (\MMR 10) {}; && \node(0,0) (\Keyserver 10) {}; && \node (\Alice 10) {}; \\
};

\fill
	(\Bob) node[draw,fill=white] {\Bob{} (participant)}
	(\MMR) node[draw,fill=white] {\MMR}
	(\Keyserver) node[draw,fill=white] {\Keyserver}
	(\Alice) node[draw,fill=white] {\Alice{} (host)};

\draw [->] (\Bob) -- (\Bob 10.south);
\draw [->] (\MMR) -- (\MMR 10.south);g
\draw [->] (\Keyserver) -- (\Keyserver 10.south);
\draw [->] (\Alice) -- (\Alice 10.south);

\draw [-latex] (\Alice 1) -- node[fill=white] {$\ivk_A$} (\Keyserver 1);

\draw (\Keyserver 105) node[draw,align=center,fill=white,minimum width=12em] {$\sig^i_{\mathsf{Server}} = $ Signature over \\ $\meetingUUID, \userID, \ivk_i$};

\draw [-latex] (\Keyserver 2) -- node[fill=white] {$\sig^A_{\mathsf{Server}}$} (\Alice 2);

\draw [dotted] (\Bob 2.south) -- (\Alice 2.south);

\draw (\Bob 3) node[draw,align=center,fill=white] {$(\pk_B, \sk_B) = \cboxkeygen()$ \\ $bundle_B \leftarrow (\sig^B_{\mathsf{Server}}, \sig_B, pk_B)$};
\draw (\Alice 3) node[draw,align=center,fill=white] {$(\pk_A, \sk_A) = \cboxkeygen()$ \\ $bundle_A \leftarrow (\sig^A_{\mathsf{Server}}, \sig_A, pk_A)$};

\draw [-latex] (\Alice 4) -- node[fill=white] {$bundle_A$} (\Keyserver 4.east) arc(0:180:0.25cm) -- (\MMR 4);
\draw [-latex] (\MMR 4) -- node[fill=white] {$bundle_A$} (\Bob 4);

\draw [-latex] (\Bob 1) -- node[fill=white] {$\ivk_B$} (\MMR 1.west) arc(180:0:0.25cm) -- (\Keyserver 1);

\draw [-latex] (\Keyserver 2) -- node[fill=white] {$\sig^B_{\mathsf{Server}}$} (\MMR 2.east) arc(0:180:0.25cm) -- (\Bob 2);

\draw [-latex] (\Bob 7) -- node[fill=white] {$bundle_B$} (\MMR 7) ;
\draw [-latex] (\MMR 7) -- (\Keyserver 7.west) arc(180:0:0.25cm) -- node[fill=white] {$bundle_B$} (\Alice 7);

\draw (\Alice 8) node[draw,align=center,fill=white] {Generates random \\ meeting key $\mk$};

\draw [-latex] (\Alice 9) -- node[fill=white,align=center] {$\mk$ encrypted \\ for Bob} (\Keyserver 9.east) arc(0:180:0.25cm) -- (\MMR 9);
\draw [-latex] (\MMR 9) -- node[fill=white,align=center] {$\mk$ encrypted \\ for Bob} (\Bob 9);

\draw [dotted] (\Bob 10.north)++(0,.25em) -- ([yshift=.25em] \Alice 10.north);

\draw [latex-latex] (\Bob 10) -- node[fill=white,align=center] {Encrypted \\ A/V} (\MMR 10);
\draw [latex-latex] (\MMR 10) -- (\Keyserver 10.west) arc(180:0:0.25cm) -- node[fill=white,align=center] {Encrypted \\ A/V} (\Alice 10);
\end{tikzpicture}
\caption{Protocol flow diagram for a leader accepting a participant into the meeting}
\label{fig:ladder}
\end{figure}

\subsubsection{Server Key Certificate Chains}
\label{subsubsec:servercert}

When a client $i$ joins a meeting, the Zoom server signs a statement $\sig^i_{\mathsf{Server}}$
indicating that the client's $\userID$, $\hardwareid$, and $\ivk$ are authorized. $\userID$ and
$\hardwareid$ are non-cryptographic identifiers used by the Zoom server to distinguish between users
and devices.

We use certificate pinning to strengthen the security of the server signature. Zoom clients will
ship with a DigiCert root certificate and they only trust certificates authorized for a
specific Zoom domain via a certificate chain originating from the pinned DigiCert root. Hardware Security
Modules (HSMs) are used to manage keys for an internal intermediate CA, which will in turn attest to
the servers' signing keys. Server keys are valid for a week and are rotated daily. In order to
detect certificate revocation in the event of CA or server compromise, clients require stapled OCSP
responses on the intermediate certificates they receive.

These signatures help protect against MitMs injecting users into the meeting. This feature was
released in version 5.7.0 (see Appendix~\ref{appendix:releases}).

\subsubsection{Participant Key Generation}
\label{subsubsec:partikeygen}
When any participant $i$ joins the meeting, whether before or after it starts, and whether the
leader or not, it performs the following operations:

\begingroup
\RaggedRight
\begin{enumerate*}
\item Generates new public-key \textit{ephemeral} encryption key pair: $(\pk_i, \sk_i) =
\cboxkeygen()$.
\item Queries the Zoom infrastructure for the server-generated $\meetingUUID$ for this instance of
this meeting; this is server-generated per-meeting-instance randomness that the individual
participants cannot control.
\item Computes $\binding_i \leftarrow \left( \meetingID \| \allowbreak \meetingUUID \| i \allowbreak
\| \hardwareid \| \ivk_i \| \allowbreak \pk_i \right)$.
\item Defines $\context \leftarrow \texttt{"Zoombase-1-ClientOnly-Sig-EncryptionKeyAnnouncement"}$.
\item Computes $\sig_i \leftarrow \zoomsignsign(\isk_i, \context, \binding_i)$
\item Stores $\sk_i$ for the duration of the meeting.
\item Posts $\sig_i$ and $\pk_i$ to the bulletin board, so that all participants can see it.
\end{enumerate*}
\endgroup

\subsubsection{Leader Join}\label{subsubsec:leaderjoin}

When the leader joins the meeting $\meetingID$, they:

\begingroup
\RaggedRight
\begin{enumerate*}
\item Fetches $\meetingUUID$ from the Zoom infrastructure.
\item Generates a symmetric 32-byte seed $\mk$ using a secure random number generator.
\item Gets the full list of participants $\participantList$ from the MMR.
\item For each participant $i \in \participantList$, it runs the ``Participant Join (Leader)''
subroutine for $i$.
\end{enumerate*}
\endgroup

Each $\mk$ has an associated sequence number $\mkSequenceNumber$, starting at 1 and incrementing
whenever the key changes as described in Section~\ref{subsubsec:keyrotation}.

\subsubsection{Participant Join (Leader)}
\label{subsubsec:participantjoinleader}

Given a leader $\LL$ and a participant $i$ joining meeting $\meetingID$ on $\hardwareid$, the
leader:

\begingroup
\RaggedRight
\begin{enumerate*}
\item Fetches $\ivk_i$ from the key server.
\item Fetches $\sig_i$ and $\pk_i$ from the meeting's ``bulletin board.''
\item Computes $\binding_i \leftarrow \left( \meetingID \| \allowbreak \meetingUUID \| i \allowbreak
\| \hardwareid \| \ivk_i \| \allowbreak \pk_i \right)$.
\item Defines $\textsf{Context}_\textsf{sign} \leftarrow
\texttt{"Zoombase-1-ClientOnly-Sig-EncryptionKeyAnnouncement"}$.
\item Verifies the signature: $\zoomsignverify(\ivk_i, \sig_i, \textsf{Context}_\textsf{sign},
\binding_i)$.
\item If verification fails, it aborts.
\item Computes $\metadata \leftarrow \left( \meetingID \| \allowbreak \meetingUUID \| \allowbreak
\LL \| i \right)$.
\item Defines $\textsf{Context}_\textsf{KDF} \leftarrow
\texttt{"Zoombase-1-ClientOnly-KDF-KeyMeetingSeed"}$.
\item Defines $\textsf{Context}_\textsf{cipher} \leftarrow
\texttt{"Zoombase-1-ClientOnly-Sig-EncryptionKeyMeetingSeed"}$.
\item Computes $\ciphertext \leftarrow \cboxencrypt(\sk_\LL, \pk_i, \textsf{Context}_\textsf{KDF},
    \textsf{Context}_\textsf{cipher}, \metadata, (\mk, \mkSequenceNumber))$.%
   \label{participantJoinRekeyStart}
\item Posts $(i, \ciphertext)$ to the ``bulletin board.''%
   \label{participantJoinRekeyEnd}
\end{enumerate*}
\endgroup

\subsubsection{Participant Join (Non-Leader)}

When participant $i$ joins meeting $\meetingID$, it performs the reverse of the above procedure:

\begingroup
\RaggedRight
\begin{enumerate*}
\item Fetches $\ivk_{\LL}$ from the Key server for the leader $\LL$.
\item Fetches $\sig_{\LL}$ and $\pk_\LL$ from the meeting's ``bulletin board.''
\item Fetches $(i, \ciphertext_i)$ from the ``bulletin board.''
\item Fetches the $\meetingUUID$ from the server.
\item Computes $\binding_\LL \leftarrow \left( \meetingID \| \allowbreak \meetingUUID \| \LL
\allowbreak \| \hardwareid \| \ivk_\LL \| \allowbreak \pk_\LL \right)$.
\item Defines $\textsf{Context}_\textsf{sign} \leftarrow
\texttt{"Zoombase-1-ClientOnly-Sig-EncryptionKeyAnnouncement"}$.
\item Verifies the signature: $\zoomsignverify(\ivk_{\LL}, \sig_\LL, \textsf{Context}_\textsf{sign},
\binding_\LL)$.
\item If verification fails, it aborts.
\item Computes $\metadata \leftarrow \left(\meetingID \| \allowbreak \meetingUUID \| \allowbreak \LL
\| i \right)$.
\item Defines $\textsf{Context}_\textsf{KDF} \leftarrow
\texttt{"Zoombase-1-ClientOnly-KDF-KeyMeetingSeed"}$.
\item Defines $\textsf{Context}_\textsf{cipher} \leftarrow
\texttt{"Zoombase-1-ClientOnly-Sig-EncryptionKeyMeetingSeed"}$.
\item Decrypts $(\mk, \mkSequenceNumber) \leftarrow \cboxdecrypt(\sk_{i}, \pk_{\LL},
\textsf{Context}_\textsf{KDF}, \textsf{Context}_\textsf{cipher}, \metadata, \ciphertext)$.
   \label{participantJoinRekeyNonLeader}
\end{enumerate*}
\endgroup

Now all participants have access to the shared meeting key $\MK$, and can encrypt and decrypt
meeting streams accordingly. Participants use an additional HKDF step to derive different subkeys
for different message types (e.g.\ chat, video), mixing in a distinct flag for the message type and
also the $\meetingID$, the $\meetingUUID$, and the ID of the message sender.

\subsubsection{Key Rotation}
\label{subsubsec:keyrotation}
At any point later in the meeting, the leader can generate a new 32-byte value $\mk'$. The leader
performs steps \ref{participantJoinRekeyStart}-\ref{participantJoinRekeyEnd} of ``Participant Join
(Leader)'' for all participants, with the updated $\mk'$ value. All participants see the rekey
signal on their signaling channel, and perform step \ref{participantJoinRekeyNonLeader} of
``Participant Join (Non-Leader).'' Each participant ensures $\mkSequenceNumber$ in the ciphertext
sent by the leader is greater than the previously known $\mkSequenceNumber$; otherwise the key
rotation is ignored.

Participants do not immediately encrypt using the new meeting key; they wait about 2
seconds to ensure all participants smoothly transition over. Additionally, as specified in Section~\ref{subsubsec:lpl}, they wait
for a signature from the leader certifying the list of users the key has been shared with. This ensures that users always know for whom
they are encrypting. All encrypted UDP packets are prefaced
with the 4-byte $\mkSequenceNumber$, so participants know which version to use for decryption.

The leader should trigger a rekey whenever a participant enters or leaves the meeting. However,
if multiple users join in short succession, the leader may choose to wait for a short amount of time
and add all the newly-joined users at once. On
the other hand, rekeys when users leave meetings might be delayed for up to 10 seconds,
which ensures that leaving users can at most only decrypt meeting content sent
shortly thereafter (or up to a couple of minutes if the
server is suppressing messages to prevent the leader from rotating the key).
Until a user begins to encrypt using a new key unknown to the leaving
participant, the leaving participant will continue to be displayed as participating
in the user interface (detailed in Section~\ref{subsubsec:lpl}).

As a final security measure, leaders rotate the meeting key every five minutes even if there have not
been any participant changes, which provides certain \textit{liveness} properties detailed in Section \ref{subsubsec:liveness}.

We stress that each $\mk$ is independently generated, so knowing the previous $\mk$ provides
no information about the subsequent $\mk'$.

\textbf{Note: } Before Zoom client version 5.12, newly joined users might have received keys up to 15 seconds old. Additionally, participants did not wait for the corresponding leader-signed participant list to start encrypting with a new meeting key.

\subsubsection{Leader Participant List}\label{subsubsec:lpl} A meeting leader maintains a ``leader
participant list'' ($\LPL$) tabulating all the users in the meeting. For each user currently in the
meeting, the $\LPL$ keeps track of a hash over their $\binding_i$, which includes their $IVK_i$,
$pk_i$, $\userID$, and $\hardwareid$, as well as their display name. For users who have left the
meeting, the $\LPL$ tracks only their $\userID$, $\hardwareid$, $\ivk_i$, and display name.

The $\LPL$ is used to drive the participant list in the user interface, which records both users
currently in the meeting and those who have left.

Currently, the participant list in the user interface only identifies users through their self-selected display name and
profile picture. Changes to participants' display names are relayed by the server to the leader who
includes them in the $\LPL$: a compromised server can change the display names of any meeting
participant. As such, display names should not be relied on to establish the participants'
identities. Attestations from identity providers (Section \ref{subsec:idpattestationmeetings}) can also strengthen in-meeting identity by displaying additional identifiers that cannot be tampered with.
Later, we will introduce a strong notion of cryptographic identity in meetings (Section \ref{sec:identitykeymanagement}) to further address these limitations.

The $\LPL$ is represented as a sequence of operations such as adding a user to the meeting, or
noting when a user has left. Every time there is such an operation, the leader increments a counter
$v$ representing the total number of operations and signs over a data structure (called a
\textit{link}) containing the counter, the hash of the previous link, and the current operation. If
there are more than 20 links in the chain, the leader can coalesce all the previous links into a
smaller number of links. The old links are then deleted in order to save space.

Leaders post a signature over the latest link to the bulletin board whenever membership changes, and
broadcast it over the signaling channel at designated ``heartbeat intervals'':
%
\begin{align*}
    H_i &= \mathsf{SHA256}(\binding_{\LL} \| \mathsf{SHA256}(\LPL_v) \| v \| t \| \mkSequenceNumber \| H_{i-1} \| \textsf{timestamp}_l  ) \\
    S_i &= \zoomsignsign \left(\isk_{\LL}, \context, H_i \right)
\end{align*}
%
where $\context$ is $\texttt{"Zoombase1-ClientOnly-Sig-Leader\-Participant\-List"}$, $t$ increments
on every send, $v$ increments whenever the $\LPL$ changes, $\mkSequenceNumber$ increments on
every $\mk$ rotation, $H_{i-1}$ is the previous heartbeat's hash, and $\textsf{timestamp}_l$ is a monotonically increasing timestamp as recorded by the leader's local clock.

By replaying the sequence of operations in the bulletin board, the other participants can
reconstruct the current list of participants, so they know who to rekey for if the leader drops out
and they become the new leader. Evil servers might try to withhold updates the leader makes here, to
hide when bad actors are kicked out. As such, the leader also sends a low bandwidth ``heartbeat''
over the signaling channel. Heartbeats should go out at least every 10 seconds. All participants
observe and verify these heartbeats, and if they fail to receive ten heartbeats in a row, they
should drop out of the meeting. This mechanism prevents the server from withholding updates to the $\LPL$ for
 an extended period of time.

Heartbeats certify both the $\mkSequenceNumber$ and the list of participants for whom $\mkSequenceNumber$ is accessible.
Because users wait for the heartbeat certifying a certain meeting key before encrypting with it, the
participant list in the user interface always reflects the list of participants users are encrypting for.

When a leader does drop out of a meeting, the Zoom server picks a new leader arbitrarily and sends a
signal to participants indicating that the leader has changed. The new leader then coalesces the
chain as described above, and other participants verify that the new leader is present in the new
$\LPL$.

For users in the meeting, clients remember the mapping between $(\userID, \hardwareid)$ and hash
over the corresponding $\binding_i$, and ensure that the hash remains stable across new links and
leader changes. If a user leaves the meeting, it is enforced that any user who rejoins with the same
$\userID$ and $\hardwareid$ must have the same $\ivk_i$, but not necessarily the same $\pk_i$. These
guarantees persist only over the course of a single meeting.

One unavoidable attack the Zoom server can perform is \textit{partitioning} the meeting: for example, split the participants of an ongoing meeting in two groups (each with its own leader), and tell each group that the other half dropped out. Partitioning attacks cannot be avoided while tolerating participants abruptly dropping out of meetings. However, since each heartbeat includes the previous heartbeat's hash in the signature material, if two participants accept the same heartbeat (i.e., they are in the same partition) they must also agree on the history of the meeting. In other words, partitions cannot be reconciled as their heartbeat chains have diverged.

\textbf{Note: } Before Zoom client version 5.13, the heartbeat signature did not include the previous heartbeat's hash in the signature material.
As such, different meeting participants might have disagreed on the past history of the meeting, in the case of meeting partitions
due to bad network conditions or server compromise.

\subsubsection{Liveness}\label{subsubsec:liveness}
An important security property in video meetings (and other synchronous communications) is \textit{liveness}: attackers
should not be able to significantly delay data streams or meeting management actions (such as adding or removing users).

To strengthen liveness, each meeting participant generates and uploads
192-bit unpredictable nonces $N$ at regular intervals\footnote{To limit bandwidth, the frequency degrades quadratically with the number of participants in the meeting. For meetings of at most 10 participants, the interval is about 3 minutes.}. When the meeting leader rekeys the meeting, each participant's
ciphertext includes their most recent nonce as associated data. 
Participants only accept ciphertexts whose associated data includes one of their two most recent nonces (to tolerate race conditions). This ensures that received keys have been sent recently, i.e., \textit{after} the recipient generated the relevant nonce.
This mechanism guarantees the recency of \textit{meeting keys}. Because leaders rotate the meeting key at least every five minutes (more frequently if the set of participants changes), and users stop using old meeting keys for decryption 10 seconds after receiving a newer key, meeting streams are also guaranteed to be relatively recent.

\textbf{Note: } Before version 5.13 of the Zoom meetings client, the liveness bounds worsened with the number of leader changes. Despite that, attacking liveness by forcing a high number of leader changes would likely make participants suspicious: the UX notifies users of each leader change, which is not frequent in regular meetings.

\subsubsection{Locked Meetings}
\label{subsubsec:lockedmeetings}
Hosts and co-hosts have the ability to lock and unlock the meeting. While a meeting is locked, no
new users will be admitted into the meeting. In non-E2EE meetings, the server performs all access
control, but locked E2EE meetings will offer stronger guarantees.

When the leader presses the ``Lock Meeting" or ``Unlock Meeting" buttons in the user interface,
their client adds a corresponding link to the $\LPL$. Other participants' clients show that the
meeting is locked only when it is set in $\LPL$; the server does not have the ability to influence
this part of the user interface. When a locked meeting becomes unlocked (as indicated by the
$\LPL$), all participants' user interfaces display a prominent warning indicating the change. 

Note that due to the tolerances in propagating the $\LPL$, the server might prevent some participants
from learning that the host has locked a meeting by withholding the relevant link and selecting a
new host within 100 seconds. However, because each heartbeat includes the hash of the previous one,
this would result in a meeting partition between the participants who received the lock link and
those who didn't.

While the meeting is locked, the leader's client will refuse to send the meeting key to any new
participants who request to join. However, if a user leaves and then rejoins with the same $\ivk$
(as is recorded in the $\LPL$), the leader allows them to rejoin. This lets participants who drop
out due to network issues automatically reconnect even while the meeting is locked. 

If the leader changes while the $\LPL$ indicates that the meeting is locked, participants ensure
that the new leader was in the previous $\LPL$. If not, they drop out of the meeting. The new leader
can then copy over the locked bit and the list of participants from the old $\LPL$ into the new
link.

Co-hosts are also able to lock and unlock the meeting. They do this by sending a signed message to
the leader via the bulletin board. The leader ensures that the co-host is really a member of the
current $\LPL$ before processing the change, and trusts the server to identify whether each
participant is actually a co-host. Since the server also has the ability to select a new meeting
host among existing participants of a locked meeting, this change does not significantly degrade the
security of the meeting. In order to prevent replays, co-hosts sign over the latest $\LPL$ link
hash, and leaders ensure that this matches their view of the $\LPL$ before accepting. If the $\LPL$
changes before the co-host's message was received and processed, the co-host tries again.

From a security perspective, once a participant learns that the meeting is locked and checks that
all current participants are trustworthy (e.g., via a meeting leader security code check), they can
be sure that no unintended parties have or will have access to the meeting until an ``unlocked
meeting" warning is displayed. 

These additional guarantees for locked E2EE meetings were added in Zoom client version 5.6.0 (see
Appendix~\ref{appendix:releases}).

\subsubsection{Meeting Teardown}
At the end of the meeting, or when leaving a meeting early, all participants should discard all
meeting keys, all keys derived from those meeting keys, and the ephemeral DH private keys $\sk_i$
they generated when they joined.

The intent here is to provide forward secrecy. That is, if an adversary can record all encrypted
messages relayed between Zoom clients during the meeting, and can later recover all keys stored on a
user's device after the meeting ends, they still cannot recover the meeting data.

\subsection{Meeting Leader Security Code}\label{subsec:securitycode} If all participants can verify
the authenticity of the leader's public key ($\ivk_{\LL}$), they are safe from MitM attacks. The
Zoom client exposes the following ``meeting leader security code'' in the security tab:
$$\mathsf{Digits}(\SHATWO(\SHATWO(\texttt{"Zoombase-1-ClientOnly-MAC-SecurityCode"}) ||
\SHATWO(\ivk_{\LL})))$$
$\mathsf{Digits}$ extracts a string of 39 decimal digits from a SHA-256 hash, representing just over
129 bits of information. This representation is more human-readable and more internationalizable
than the full hexadecimal hash. Crucially, every Zoom client in the meeting independently computes
these codes from the $\ivk_{\LL}$ used in the handshake protocol. The length of the code is long
enough to protect against second pre-image attacks. The leader reads out the meeting leader security
code, after which everyone in the meeting in turn does the same thing. If the code does not match,
the participant should speak up in the meeting, and the leader should rotate the meeting key by
kicking them out; they may be allowed to rejoin and try again. By having the leader go first,
participants verify that they all agree both on which of them is the leader, and on their
$\ivk_{\LL}$. Both properties are necessary to detect MitM attacks.

If deep fake technology\footnote{We use ``deep fakes'' to refer to manipulated and/or fabricated
audio/video data that uses synthetic media techniques to replace the likeness of one person with
another. Using a ``deep fake'' (especially in real-time) of a meeting participant could potentially
deceive others about the identity of that participant.} is a concern, or the participants do not
know each other in advance, this verification can also happen over a different out-of-band secure
channel.

Non-leader participants see a notification prompting them to re-perform the security code checks
whenever the meeting leader changes. These additional checks prevent a compromised Zoom server from
changing the meeting leader over the course of a meeting without being detected.

We considered other approaches to the meeting leader security code, such as mixing more of the
handshake data into the displayed code. While more mixins would be more robust to attacks that try
to confuse participants by mixing members from different meetings, we see a UX advantage of ``one
leader, one code.''

\subsection{E2E Encryption for Breakout Rooms}
\label{subsec:bor}
The Breakout Rooms feature allows splitting a Zoom meeting into multiple sub-meetings. The host can
assign participants to rooms, or allow them to choose the room that they want to join, and can
broadcast chat messages to all breakout rooms at once. While main meeting participants (including
the host) do not have access to meeting content from breakout rooms that they are not a participant
of, the host does receive some metadata about the ``activity status'' of participants in each
breakout room to help them monitor engagement, including for example whether participants have their
video on, are using reactions, or sharing their screen.

In E2EE meetings, we implement Breakout Rooms by having each room function as its own independent
meeting, with its own leader, participant list, and sequence of meeting keys. As users leave the
main meeting and join a breakout room, both meetings rotate their keys. In addition, after they join
a breakout room, participants are also re-added by the leader to the main meeting so that they can
keep decrypting messages broadcast by the main meeting host. Since they continue to have access to
the meeting key, breakout room participants are still part of the main meeting LPL, but the
participants panel of the meeting UX indicates that they are ``In a breakout room.'' If the main
meeting is locked, participants are still able to go in and out of it to join breakout rooms, as the
leader of the main meeting will let them back in given that they keep the same $\ivk$ (as explained
in Section~\ref{subsubsec:lockedmeetings}). 

Users in a breakout room can check the security codes with the breakout room leader to ensure that
there are no MitM attacks on the breakout room itself. Since there is no cryptographically enforced
relationship between the main meeting and breakout rooms, such as the fact that the assignments of
people to rooms reflect the intentions of the meeting host, breakout room participants should also
make sure that other participants in their breakout room are expected to be there before discussing
sensitive matters (as in regular meetings). However, breakout room participants cannot see the main
meeting's leader security code, and are not notified if the leader of the main meeting changes while
they are in a breakout room. Therefore, an active insider could add a breakout room participant to a
different main meeting when they try to rejoin it after entering a breakout room. Then, the attacker
could broadcast messages to that participant which would appear to come from the original host of
the main meeting (this would work even if the main meeting were locked). As such, users worried
about active attacks from insiders should be suspicious of broadcast messages received while in a
breakout room. 

An attacker might also try to join an unlocked main meeting and immediately go to a breakout room to
avoid being identified by having to turn their camera on or being asked to check security codes. The
attacker could use the same display name and picture of another meeting participant, either one who
recently left the meeting or one that the attacker has kicked out themselves (by controlling the
network or the Zoom infrastructure). In this case, the same participant name would appear twice as
``left'' and ``In a breakout room'' in the participant list, which may be hard for other
participants or the leader to spot. While analogous attacks are possible even when breakout rooms
are not in use, they might be harder to recognize and act on in this scenario: for example,
participants in a breakout room do not get a video tile in the gallery view. We recommend that all
meeting participants carefully monitor the participant list, and that hosts lock their meeting
whenever possible.

Finally, when participants leave a breakout room to rejoin the main meeting, an insider might trick
them into joining a different main meeting than the original one (even if the latter were locked).
As such, when switching between the main meeting and breakout rooms, all participants should recheck
leader security codes.

In future updates, we plan to further strengthen the guarantees offered by this feature, by not
making participants leave and then rejoin the main meeting when entering or exiting breakout rooms,
and having breakout room participants enforce that other participants of their breakout room are
also listed in the main meeting's participant list. This will better mitigate the risks above, and
require less trust in the Zoom server when using E2EE Breakout Rooms.

\subsection{Abuse Management and Reporting}
If a user experiences abusive behavior and wishes to report it to Zoom's Trust and Safety team, they
simply upload the unencrypted data normally collected in an abuse report (e.g., a description of the
abuse and some portion of the meeting content) to Zoom for review. This protocol is imperfect, since
it potentially could allow a bad meeting participant to ``frame'' an honest meeting participant for
abuse that didn't happen. For the same reason, it allows an actual abuser to disavow uploaded
evidence of their abuse. We think for now, the framing behavior is rare and only possible with
access to good ``deep fake'' technology.

Future refinements are possible. Participants could sign their outgoing video streams, and other
participants will only allow meetings to proceed if all streams are appropriately signed. This
change would defeat the two attacks above, but with major drawbacks:
%
\begin{description}
    \item {\bf Performance:} Signing and verifying individual UDP video streams is expensive in
    terms of bandwidth and computation. More research is required to make this change practical.
    \item {\bf Repudiation:} Honest participants might not want an indelible record that they said
    something. They might understandably want to treat meetings as ephemeral in accordance with
    their standard data retention practices.
\end{description}

Given these challenges, we will revisit our decisions at a later date as we gain more operational
experience with the current proposal.

\subsection{IDP Attestations for E2EE Meetings}
\label{subsec:idpattestationmeetings}

If a user's account is configured to support IDP attestations
(Section~\ref{sec:idpattestations}), they can use an attestation in E2EE
meetings to prove to other meeting participants that they are part of a specific
organization (identified by its Account Domain Name, or ADN) in which they hold a specific email address
(as vouched for by the organization's designated IDP, and which they logged into
Zoom with). Attestations by a trusted IDP reduce the need to explicitly check security codes.

Upon joining a meeting, each device obtains an IDP attestation, which
authenticates the signing key $\ivk$ used to join the meeting as described in
Section~\ref{subsec:generateattestation}. Currently, the \texttt{zoom-identity-snapshot} field of the attestation
includes the $\ivk$; once we start leveraging sigchains in meetings (see
Section~\ref{subsec:keyagreementidentity} for details),  we plan to extend the
snapshot with the tails of the given user's sigchains. 

The user signs the IDP attestation and their ADN with their $\ivk$, and
temporarily stores the attestation and signature on the Zoom servers. To share
this information only with the intended meeting participants, the user posts to
the meeting bulletin board an ``identity sharing token'' (along with the signed
$\binding_i$ described in Section~\ref{subsubsec:partikeygen} ``Participant Key
Generation''), which other participants can present to the server in exchange
for the attestation. Identity sharing tokens are computed as an HMAC of some
metadata about the attestation (such as whether it contains the user's email
address), using a random 32-byte symmetric key generated by the Zoom servers for
each user's device in each meeting. Identity sharing tokens have a lifetime of
24 hours, and can be used to fetch any matching attestation for that user's
device.  An IDP attestation can be used across multiple meetings but has a
relatively short lifetime, which is set by the IDP, defaulting to 48 hours.

When displaying another participant's identity in the user interface during a
meeting, clients that successfully fetch an identity attestation will verify the
signature of ADN and attestation by $\isk$, verify that this ADN (in addition to
the email address in the attestation) matches what is provided by the Zoom
server, and verify the attestation as detailed in
Section~\ref{subsec:validateattestation}; in particular, the $\ivk$ in the
$\binding$ must be consistent with the contents of attestation's
\texttt{zoom-identity-snapshot} field. If the checks are successful, the
interface displays to the user the email address from the attestation and
details about the authenticating ADN and IDP. The verifying user should review
the displayed email address and ADN and confirm that they are the expected
identifiers for the user they are meeting with.

Meeting participants' clients may perform these checks asynchronously during a
meeting, but in the future we may offer the option to configure a meeting such
that the host must complete this verification before admitting
a joining participant. Requiring this verification
before key exchange can help increase the security of meetings that are, 
for example, restricted to users in specified accounts. 

\subsection{E2EE Meetings with Cryptographic Identity}
\label{subsec:keyagreementidentity}
\textbf{Note:} This feature is not currently available. We plan to release it in a future update.

In Section~\ref{sec:identitykeymanagement} we describe how we leverage sigchains to build a strong
multi-device notion of cryptographic user identity. We plan to leverage this notion in the context
of E2EE meetings in order to strengthen the guarantees provided by security codes and IDP
attestations in detecting and preventing MitM attacks.

The server signature $\sig^i_{\mathsf{Server}}$ as described in Section~\ref{subsubsec:servercert} will also include the
sigchain tails for the corresponding user, email, and account sigchains. These tails will also
be included in the signed $\binding_i$ generated in the ``Participant Key Generation'' procedure of
Section~\ref{subsubsec:partikeygen}, and in the \texttt{zoom-identity-snapshot} field of the IDP
attestation (if one is used in the meeting). 

In a meeting, Alice's client verifies Bob's sigchains (and IDP attestation, if present) before
Alice's client displays identifiers for Bob in the UI. To do so, Alice's client fetches Bob's user
sigchain (which includes $\ivk_i$), email sigchain, and account sigchain. Alice's client
verifies the server signature $\sig^i_{\mathsf{Server}}$, checks that the tails
of the received sigchains match those in $\sig^i_{\mathsf{Server}}$ and in the
$\binding$, checks that Bob's latest sigchain is consistent with any previous
retrievals of Bob's sigchain, and verifies the IDP attestation if one is present
(including checking that the sigchain tails included in the attestation match).
As for IDP attestations, these checks might be performed asynchronously, or
mandated before the host performs the key exchange to limit who can access a
meeting.

To minimize the need to request new attestations, users accept attestations that
do not necessarily cover the latest sigchain tails as long as the new links
added since the IDP's snapshot do not revoke the device currently being used in
the meeting and do not change the user's email or account identifiers.

The Zoom server will provide access control to ensure that sigchains are visible to other meeting
participants only for a short duration after a meeting begins. If Alice has never been in a meeting
with Charlie, Charlie will have no information regarding Alice's sigchain's contents, length, or
update frequency.

\subsection{Security Properties for E2EE Meetings}
\label{subsec:secprop}
The Identity Management System, Bulletin Board and Signaling Channel as enumerated in
Section~\ref{subsec:comp} are deployed by Zoom, and protect against outsiders using TLS. Attackers
classified as insiders by our threat model could monitor or meddle with these components. An insider
monitoring such components (a passive attack) would expose meeting metadata, which is stated as a
limitation of our designs in Section~\ref{subsec:overall-limit}, but would not otherwise compromise
the confidentiality of the meeting.

We prevent outsiders from joining meetings through passwords, waiting rooms, and the other
non-cryptographic server-enforced access control features described in
Section~\ref{subsec:general-meetings}. TLS and encryption of the meeting streams protect the
confidentiality and integrity of the meeting against outsiders who might control the participants'
network.

Within the same meeting, the encrypted streams sent by each participant are protected against replay
attacks by using encryption nonces as counters. Even across different meetings, the streams cannot
be replayed thanks to the fact that participants delete all the ephemeral keys once a meeting is
over (which also guarantees forward secrecy). 

We aim to minimize the damage that an active insider can perform without being detected. First, an
insider can force participants to drop out of a meeting, as well as partition them into separate
meetings, each with its own leader, and add extra participants circumventing all the above
server-enforced features. Our protocol ensures that the meeting leader will be able to detect any
participant obtaining access to meeting encryption keys by monitoring the participant list for
unexpected entries (for example, by recognizing the participants' faces in
their video streams). If the host observes the same user leaving the meeting
four or more times, the participant list will reflect the number of observed
leaves. Liveness properties ensure that actions like rekeying the
meeting or adding/removing participants cannot be arbitrarily delayed, and
furthermore, that audio/video streams displayed are relatively recent.

Detecting unauthorized participants can be challenging in large meetings or in certain views, such
as when the leader is sharing their screen. In the future, a stronger notion of identity will be
leveraged to highlight potential eavesdroppers in the UI, such as those outside of the host's
organization or guest users.

We stress that, even when using IDP attestations, seeing a specific user identity in the participant
list of a meeting does not imply that the corresponding user has chosen to participate in the
meeting or is still actively participating, but only that that user could potentially have access to
the encrypted meeting contents. A malicious insider could either trick the leader into including a
user in the participant list (when the user is not actually present in the meeting), or hide the
fact that a participant has left a meeting (so that other users are convinced they are still
participating). All such participants would still trigger Contact Sync warnings as detailed in
Section~\ref{subsec:contactsync} (once that feature is deployed), and clients will remember their
identities for future meetings. We believe that preventing these issues would add too much
complexity and overhead to the protocol.

An active attacker can also try to perform a MitM attack against the meeting. This class of attacks
is mitigated by the meeting leader security code, which should be re-checked every time a
participant joins or rejoins the meeting (including when moving in and out of breakout rooms), or
whenever the meeting leader security code changes as indicated by a UI notification.

When leveraged in E2EE meetings (under the assumptions in Section~\ref{subsec:idpsecurity}) an IDP
attestation confirms that a meeting participant's long-term device key belongs to a member of a specific account, which has vouched for that participant's identity (e.g. email address) through a third party identity provider. IDP attestations are a mitigation against MitM attacks and serve as an alternative to checking security codes.

We also stress that, as discussed in Section~\ref{subsec:bor}, when in an E2EE meeting using Breakout
Rooms, participants should be skeptical of broadcast messages from the meeting host and should
carefully monitor the participant list of the main meeting.

Another attack we aim to defend against an adversary who is recording encrypted meeting traffic
today, expecting to be able to break classical encryption at a later time using a quantum computer.
Therefore, we use both the Kyber post-quantum secure key encapsulation and the X25519 key exchange
to strengthen the encryption used to transmit the meeting key between the leader and participants.
The cryptography and security implications are analogous to those for device-managed encryption
(Section~\ref{subsubsec:sigchainpqsecurity}).

We have published~\cite{eurocrypt-2023-32928} a formal security analysis of our core E2EE meetings protocol,
which precisely characterizes the liveness, confidentiality, and security properties it achieves (but does not consider post-quantum security).

\subsubsection{Areas to Improve}
While E2E meetings offer strong security properties to Zoom users, there are still opportunities for
improvement, both in the key agreement layer and in the identity layer.
\begin{description}
\item {\bf Meddler-in-the-Middle.} The meeting leader security code and IDP attestations are
countermeasures for the classic MitM attack, wherein Bob isn't actually connecting to Zoom; he's
connecting to Eve who is proxying his communications. Both solutions have limitations: they can be
defeated by deep fake technology, introduce some UX friction, or require additional trust assumptions.
Sigchain-backed identities (Section~\ref{subsec:keyagreementidentity}) and the ZTT
(Section~\ref{sec:ztt}) will further improve the security properties and UX.
\item {\bf Anonymous Eavesdropper.} An adversary, in conjunction with a malicious Zoom server, types
in a name of their choosing, turns off video, mutes their microphone and just observes. Checking
security codes and cryptographic identity can help address this problem partially.
\item {\bf Impersonation Attacks Within the Meeting.} Even if Alice and Bob are both authorized to
be in the meeting, if Alice has the help of a malicious server, she can inject audio/video for Bob.
Charlie would have no way of knowing that Bob's stream was being faked.
\end{description}
